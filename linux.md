# 操作系统

- 用户空间

    用户是通过用户空间与操作系统打交道的，
    
    程序员开发使用的应用程序也位于用户空间

    用户空间不能直接访问内核，但是可以通过系统调用来访问

- 内核空间
# 进程


进程  
一个进程是通过另一个进程创建的，通过fork系统调用实现的  
产生的新的进程就是子进程  
所有的进程都有一个父进程,init进程除外  

wait 系统调用用来暂停父进程，直到子进程退出  

进程0负责系统初始化工作，并创建进程1，进程1 也叫做init进程

init进程，mingetty、agetty程序分别在虚拟终端和串口终端进行监听

---

进程状态
- 运行  
    进程被创建后，就变为运行进程
    意味着内核已经为cpu执行进程建立起所有的结构，并获取所有必要的信息
- 就绪  
    进程准备变为运行进程但还没有被选中运行时，处于就绪状态
- 睡眠
- 死亡
- 僵尸进程：进程已经结束，但是其父进程没有调用它的wait 。除了进程描述符仍被保留外，其他的资源都被释放并回收




任何进程都可以通过调用wait、waitpid来获取子进程的退处状态。即使子进程已经终止，也需要为父进程保留少量信息。
    

---
进程描述符

每个进程都有一个进程描述符，存放描述进程的所有信息  
内核采用循环双向链表来存放所有进程描述符 
 

进程的生命周期中，进程描述符记录的信息
- 进程的属性
- 进程间的关系
- 文件管理
- 信号管理
- 进程的信任状态
- 资源限制
- 与调度相关的字段


---

进程相关的字段

1、state记录进程的状态  
2、pid 进程的唯一标识符


---
操作系统通过系统调用fork、vfork、clone来完成进程的创建。    
这三个系统调用最终都调用了内核函数do_fork

## fork函数

返回了两次，一次实在父进程，一次实在子进程。    
如果在子进程中返回，将返回0。
如果在父进程中返回，将返回子进程PID。       
fork 函数被调用时，该函数把包括该系统调用表索引在哪的一些必要信息放入适当的寄存器   


## vfork 函数

vfork 函的父进程一直阻塞，直到子进程调用exit或exec为止

## clone 函数

把一个指向函数的指针和该函数的参数作为自己的参数。  
由do_fork 创建的子进程刚一诞生就调用这个函数


